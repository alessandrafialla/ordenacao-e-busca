<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trabalho Prático - Alessandra Fialla</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="navbar"></div>
    
    <script>
        // Carrega a barra de navegação de navbar.html
        document.addEventListener("DOMContentLoaded", () => {
            fetch('navbar.html')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Erro ao carregar navbar.html');
                    }
                    return response.text();
                })
                .then(data => {
                    document.getElementById('navbar').innerHTML = data;
                })
                .catch(error => console.error('Erro ao carregar a navbar:', error));
        });

    </script>

    <main>
        <div class ="titulo1">
        <h4> Trabalho Prático - Ordenação e Busca </h4>
        </div>
        
        <div class="texto-principal">
        <p>Trabalho desenvolvido para a disciplina de <b>Algoritmos II</b>,<br>
            ministrada pelo professor Prof. Elias P. Duarte Jr. <br>
           <b>Autor:</b> Alessandra Fialla <br>
           <b>GRR:</b> 20234444
        </p>
        </div>

        <div class="relatorio">
            <h3>Relatório</h3>
            <p>O objetivo do trabalho era implementar e comparar algoritmos de ordenação e busca. <br>
                Dessa forma, foram implementados os seguintes algoritmos: <br> </p>
                <ul>
                    <li>Busca Sequencial</li>
                    <li>Busca Binária</li>
                    <li>Insertion Sort</li>
                    <li>Shell Sort</li>
                    <li>Quick Sort</li>
                </ul>
                <p>Tanto o <strong>Shell Sort</strong> quanto o <strong>Quick Sort</strong> tiveram duas variações implementadas.</p>

                <p>No caso do <strong>Shell Sort</strong>, as variações consistiram em dois tipos de espaçamento:</p>
                <ul>
                    <li>Utilizando uma sequência específica (<em>sequência de Knuth.</em>).</li>
                    <li>Usando espaçamentos baseados em potências de 2.</li>
                </ul>
                
                <p>Já no <strong>Quick Sort</strong>, as variações envolveram o pivô:</p>
                <ul>
                    <li>Escolhendo a primeira posição como pivô.</li>
                    <li>Escolhendo a última posição como pivô.</li>
                </ul>
                
                <p>O objetivo dessas variações foi analisar como diferentes estratégias afetam a execução em termos de quantidade de comparações e trocas realizadas.</p>
                
                <p>O código foi desenvolvido com um menu interativo que permite uma simulação mais flexível. Por meio do menu, é possível:</p>
                <ul>
                    <li>Criar e exibir um vetor único e aleatório.</li>
                    <li>Escolher quais algoritmos executar sobre um vetor unico.</li>
                    <li>Gerar estatísticas de quantidade de comparações e trocas.</li>
                    <li>Testar a Execução 1000 vezes para cada algoritmo e visualizar estatísticas</li>
                     
                </ul>
                
                <p>Além disso, na funcionalidade de busca,o menu permite que o usuário defina se deseja buscar um elemento aleatório ou um valor específico (neste caso, o valor deve ser digitado).</p>
                <p> Com essas opções disponíveis, foi possível observar os seguintes pontos(verificar logs de teste):</p>
                <p> A busca Binária é consistentemente mais eficiente que a busca sequencial, tendo a quantidade de comparações muito menores para vetor de mesmo tamanho e mesmos valores. Com a observação de que a busca binária necessita de um vetor ordenado.</p>
                <p> A Eficiência do Shell Sort varia bastante em relação a característica da definição dos gaps. Sendo que o gap de acordo com a sequência de Knuth foi muito mais eficiente que o em potência de 2.</p>
                <p> Os algoritmos Quick Sort e Shell Sort(knuth) tiveram desempenho consideravelmente superiores ao Insertion Sort, que teve a maior contagem de comparações, o que era esperado por ser classificado como algoritmo quadrático.</p>
                <p> </p>

            </p>
        </div>

   
    </main>
    
</body>
</html>